[
  {
    "id": 1,
    "question": "Oracle의 실행 계획에서 FULL TABLE SCAN이 항상 나쁜 것은 아닙니다. 어떤 경우에 FULL TABLE SCAN이 효율적일 수 있을까요?",
    "options": [
      "인덱스가 없는 경우",
      "테이블의 대부분의 행을 검색해야 할 때",
      "테이블이 매우 작은 경우",
      "위의 모든 경우"
    ],
    "correctAnswer": 3,
    "hint": "FULL TABLE SCAN의 효율성은 여러 요인에 의해 결정됩니다.",
    "difficulty": "hard",
    "category": "성능 최적화"
  },
  {
    "id": 2,
    "question": "Oracle의 UNDO 세그먼트의 주요 목적은 무엇인가요?",
    "options": [
      "데이터 백업",
      "트랜잭션 롤백",
      "데이터 암호화",
      "인덱스 관리"
    ],
    "correctAnswer": 1,
    "hint": "변경사항을 취소하거나 이전 상태로 되돌리는 기능과 관련이 있습니다.",
    "difficulty": "hard",
    "category": "트랜잭션 관리"
  },
  {
    "id": 3,
    "question": "Oracle SQL에서 인덱스 스캔이 가장 적합한 경우는?",
    "options": [
      "테이블이 클 때",
      "검색할 행이 적을 때",
      "모든 행을 검색할 때",
      "테이블이 작을 때"
    ],
    "correctAnswer": 1,
    "hint": "인덱스 스캔은 검색할 행이 적을 때 효율적입니다.",
    "difficulty": "hard",
    "category": "성능 최적화"
  },
  {
    "id": 4,
    "question": "Oracle SQL에서 파티셔닝의 주요 목적은?",
    "options": [
      "데이터 백업",
      "데이터 암호화",
      "대용량 데이터의 관리와 성능 향상",
      "데이터베이스 복구"
    ],
    "correctAnswer": 2,
    "hint": "파티셔닝은 대용량 데이터를 효과적으로 관리하고 성능을 향상시킵니다.",
    "difficulty": "hard",
    "category": "데이터베이스 설계"
  },
  {
    "id": 5,
    "question": "Oracle SQL에서 트리거를 비활성화하는 명령어는?",
    "options": [
      "DISABLE TRIGGER",
      "DROP TRIGGER",
      "DEACTIVATE TRIGGER",
      "ALTER TRIGGER"
    ],
    "correctAnswer": 0,
    "hint": "트리거를 비활성화하는 명령어입니다.",
    "difficulty": "hard",
    "category": "데이터베이스 객체"
  },
  {
    "id": 6,
    "question": "Oracle SQL에서 옵티마이저 힌트를 사용하는 주요 이유는?",
    "options": [
      "쿼리 성능을 향상시키기 위해",
      "데이터를 백업하기 위해",
      "데이터를 암호화하기 위해",
      "쿼리를 디버깅하기 위해"
    ],
    "correctAnswer": 0,
    "hint": "옵티마이저 힌트는 쿼리 성능을 향상시키기 위해 사용됩니다.",
    "difficulty": "hard",
    "category": "성능 최적화"
  },
  {
    "id": 7,
    "question": "Oracle SQL에서 SEQUENCE의 주요 목적은?",
    "options": [
      "데이터의 중복을 방지하기 위해",
      "일련 번호를 생성하기 위해",
      "데이터를 백업하기 위해",
      "데이터를 암호화하기 위해"
    ],
    "correctAnswer": 1,
    "hint": "SEQUENCE는 일련 번호를 생성하는 데 사용됩니다.",
    "difficulty": "hard",
    "category": "데이터베이스 객체"
  },
  {
    "id": 8,
    "question": "Oracle SQL에서 서브쿼리를 사용하는 이유는?",
    "options": [
      "데이터를 백업하기 위해",
      "복잡한 쿼리를 작성하기 위해",
      "데이터를 암호화하기 위해",
      "데이터베이스를 복구하기 위해"
    ],
    "correctAnswer": 1,
    "hint": "서브쿼리는 복잡한 쿼리를 작성하는 데 사용됩니다.",
    "difficulty": "hard",
    "category": "고급 쿼리"
  },
  {
    "id": 9,
    "question": "Oracle SQL에서 데이터베이스 링크를 사용하는 주된 이유는?",
    "options": [
      "데이터를 백업하기 위해",
      "다른 데이터베이스와 통신하기 위해",
      "데이터를 암호화하기 위해",
      "데이터베이스를 복구하기 위해"
    ],
    "correctAnswer": 1,
    "hint": "데이터베이스 링크는 다른 데이터베이스와 통신하는 데 사용됩니다.",
    "difficulty": "hard",
    "category": "데이터베이스 연결"
  },
  {
    "id": 10,
    "question": "Oracle SQL에서 VIEW를 사용하는 주된 이유는?",
    "options": [
      "데이터의 가상 테이블을 생성하기 위해",
      "데이터를 암호화하기 위해",
      "데이터를 백업하기 위해",
      "데이터베이스를 복구하기 위해"
    ],
    "correctAnswer": 0,
    "hint": "VIEW는 데이터의 가상 테이블을 생성합니다.",
    "difficulty": "hard",
    "category": "데이터베이스 객체"
  },
  {
    "id": 11,
    "question": "Oracle SQL에서 물리적 백업과 논리적 백업의 차이는?",
    "options": [
      "물리적 백업은 데이터 파일을 백업하고, 논리적 백업은 데이터베이스 객체를 백업합니다.",
      "물리적 백업은 데이터를 암호화하고, 논리적 백업은 데이터를 백업합니다.",
      "물리적 백업은 데이터베이스를 복구하고, 논리적 백업은 데이터 파일을 복구합니다.",
      "물리적 백업은 데이터를 백업하고, 논리적 백업은 데이터를 암호화합니다."
    ],
    "correctAnswer": 0,
    "hint": "물리적 백업과 논리적 백업의 목적을 이해합니다.",
    "difficulty": "hard",
    "category": "데이터베이스 관리"
  },
  {
    "id": 12,
    "question": "Oracle SQL에서 쿼리 성능을 최적화하기 위해 사용할 수 있는 것은?",
    "options": [
      "인덱스",
      "트리거",
      "시퀀스",
      "뷰"
    ],
    "correctAnswer": 0,
    "hint": "인덱스는 쿼리 성능을 향상시킵니다.",
    "difficulty": "hard",
    "category": "성능 최적화"
  },
  {
    "id": 13,
    "question": "Oracle SQL에서 데이터의 일관성을 보장하는 트랜잭션 속성은?",
    "options": [
      "원자성",
      "일관성",
      "격리성",
      "내구성"
    ],
    "correctAnswer": 1,
    "hint": "트랜잭션의 ACID 속성 중 하나입니다.",
    "difficulty": "hard",
    "category": "트랜잭션 관리"
  },
  {
    "id": 14,
    "question": "Oracle SQL에서 파티션 테이블의 장점은?",
    "options": [
      "데이터를 암호화할 수 있습니다.",
      "데이터를 더 빠르게 검색할 수 있습니다.",
      "데이터베이스를 복구할 수 있습니다.",
      "데이터를 더 안전하게 백업할 수 있습니다."
    ],
    "correctAnswer": 1,
    "hint": "파티션 테이블은 데이터 검색 성능을 향상시킵니다.",
    "difficulty": "hard",
    "category": "성능 최적화"
  },
  {
    "id": 15,
    "question": "Oracle SQL에서 데이터베이스의 크기를 줄이는 데 사용할 수 있는 것은?",
    "options": [
      "압축",
      "인덱스",
      "트리거",
      "뷰"
    ],
    "correctAnswer": 0,
    "hint": "압축은 데이터베이스의 크기를 줄입니다.",
    "difficulty": "hard",
    "category": "데이터베이스 관리"
  },
  {
    "id": 16,
    "question": "Oracle SQL에서 PL/SQL 블록의 세 가지 주요 구성 요소는?",
    "options": [
      "DECLARE, BEGIN, END",
      "START, PROCESS, FINISH",
      "OPEN, EXECUTE, CLOSE",
      "CREATE, MODIFY, DELETE"
    ],
    "correctAnswer": 0,
    "hint": "PL/SQL 블록의 구조를 이해합니다.",
    "difficulty": "hard",
    "category": "PL/SQL"
  },
  {
    "id": 17,
    "question": "Oracle SQL에서 커서를 사용하는 주된 이유는?",
    "options": [
      "데이터를 암호화하기 위해",
      "다중 행을 처리하기 위해",
      "데이터베이스를 백업하기 위해",
      "데이터베이스를 복구하기 위해"
    ],
    "correctAnswer": 1,
    "hint": "커서는 다중 행을 처리하는 데 사용됩니다.",
    "difficulty": "hard",
    "category": "PL/SQL"
  },
  {
    "id": 18,
    "question": "Oracle SQL에서 외래 키 제약 조건의 주요 목적은?",
    "options": [
      "데이터의 무결성을 보장하기 위해",
      "데이터를 암호화하기 위해",
      "데이터를 백업하기 위해",
      "데이터베이스를 복구하기 위해"
    ],
    "correctAnswer": 0,
    "hint": "외래 키는 데이터의 무결성을 보장합니다.",
    "difficulty": "hard",
    "category": "데이터베이스 설계"
  },
  {
    "id": 19,
    "question": "Oracle SQL에서 물리적 백업을 수행할 때 사용하는 도구는?",
    "options": [
      "RMAN",
      "SQL*Plus",
      "Oracle Net",
      "PL/SQL"
    ],
    "correctAnswer": 0,
    "hint": "물리적 백업 도구입니다.",
    "difficulty": "hard",
    "category": "데이터베이스 관리"
  },
  {
    "id": 20,
    "question": "Oracle SQL에서 논리적 백업을 수행할 때 사용하는 도구는?",
    "options": [
      "Data Pump",
      "RMAN",
      "Oracle Net",
      "PL/SQL"
    ],
    "correctAnswer": 0,
    "hint": "논리적 백업 도구입니다.",
    "difficulty": "hard",
    "category": "데이터베이스 관리"
  },
  {
    "id": 21,
    "question": "Oracle SQL에서 파티션을 사용하는 주된 이유는?",
    "options": [
      "데이터의 가용성을 높이기 위해",
      "데이터베이스의 보안을 강화하기 위해",
      "대용량 데이터를 효율적으로 관리하기 위해",
      "데이터를 암호화하기 위해"
    ],
    "correctAnswer": 2,
    "hint": "파티션은 대용량 데이터를 효율적으로 관리합니다.",
    "difficulty": "hard",
    "category": "데이터베이스 설계"
  },
  {
    "id": 22,
    "question": "Oracle SQL에서 쿼리 성능을 향상시키기 위해 사용할 수 있는 힌트는?",
    "options": [
      "INDEX",
      "FULL",
      "PARALLEL",
      "ALL"
    ],
    "correctAnswer": 2,
    "hint": "쿼리를 병렬로 실행합니다.",
    "difficulty": "hard",
    "category": "성능 최적화"
  },
  {
    "id": 23,
    "question": "Oracle SQL에서 데이터의 일관성을 보장하기 위한 격리 수준은?",
    "options": [
      "READ UNCOMMITTED",
"READ COMMITTED",
"REPEATABLE READ",
"SERIALIZABLE"
],
"correctAnswer": 3,
"hint": "가장 높은 격리 수준입니다.",
"difficulty": "hard",
"category": "트랜잭션 관리"
},
{
"id": 24,
"question": "Oracle SQL에서 UNDO 테이블스페이스의 주요 목적은?",
"options": [
"데이터의 변경 사항을 추적하기 위해",
"데이터를 암호화하기 위해",
"데이터를 백업하기 위해",
"데이터베이스를 복구하기 위해"
],
"correctAnswer": 0,
"hint": "변경 사항을 추적합니다.",
"difficulty": "hard",
"category": "데이터베이스 관리"
},
{
"id": 25,
"question": "Oracle SQL에서 데이터베이스를 모니터링하는 데 사용할 수 있는 도구는?",
"options": [
"Oracle Enterprise Manager",
"SQLPlus",
"PL/SQL",
"Oracle Net"
],
"correctAnswer": 0,
"hint": "모니터링 도구입니다.",
"difficulty": "hard",
"category": "데이터베이스 관리"
},
{
"id": 26,
"question": "Oracle SQL에서 데이터베이스를 복구하는 데 사용할 수 있는 도구는?",
"options": [
"RMAN",
"SQLPlus",
"Oracle Net",
"PL/SQL"
],
"correctAnswer": 0,
"hint": "복구 도구입니다.",
"difficulty": "hard",
"category": "데이터베이스 관리"
},
{
"id": 27,
"question": "Oracle SQL에서 데이터베이스 성능을 분석하는 데 사용할 수 있는 도구는?",
"options": [
"SQL Trace",
"SQL*Plus",
"PL/SQL",
"Oracle Net"
],
"correctAnswer": 0,
"hint": "성능 분석 도구입니다.",
"difficulty": "hard",
"category": "성능 최적화"
},
{
"id": 28,
"question": "Oracle SQL에서 데이터베이스의 보안을 강화하는 방법은?",
"options": [
"사용자 권한을 관리하기 위해",
"데이터를 암호화하기 위해",
"백업을 수행하기 위해",
"데이터를 복구하기 위해"
],
"correctAnswer": 1,
"hint": "데이터를 암호화합니다.",
"difficulty": "hard",
"category": "데이터베이스 보안"
},
{
"id": 29,
"question": "Oracle SQL에서 데이터베이스의 가용성을 높이는 방법은?",
"options": [
"데이터를 백업하기 위해",
"데이터를 암호화하기 위해",
"파티셔닝을 사용하기 위해",
"클러스터링을 사용하기 위해"
],
"correctAnswer": 3,
"hint": "클러스터링은 가용성을 높입니다.",
"difficulty": "hard",
"category": "데이터베이스 관리"
},
{
"id": 30,
"question": "Oracle SQL에서 데이터를 암호화하는 데 사용할 수 있는 기능은?",
"options": [
"TDE (Transparent Data Encryption)",
"RMAN",
"Data Pump",
"Oracle Net"
],
"correctAnswer": 0,
"hint": "투명한 데이터 암호화입니다.",
"difficulty": "hard",
"category": "데이터베이스 보안"
},
{
"id": 31,
"question": "Oracle SQL에서 데이터베이스의 성능을 최적화하기 위해 사용할 수 있는 방법은?",
"options": [
"인덱스를 생성하기 위해",
"데이터를 암호화하기 위해",
"백업을 수행하기 위해",
"데이터를 복구하기 위해"
],
"correctAnswer": 0,
"hint": "인덱스는 성능을 최적화합니다.",
"difficulty": "hard",
"category": "성능 최적화"
},
{
"id": 32,
"question": "Oracle SQL에서 쿼리 실행 계획을 확인하는 방법은?",
"options": [
"EXPLAIN PLAN",
"SHOW PLAN",
"DISPLAY PLAN",
"REVEAL PLAN"
],
"correctAnswer": 0,
"hint": "쿼리 실행 계획을 확인하는 명령어입니다.",
"difficulty": "hard",
"category": "성능 최적화"
},
{
"id": 33,
"question": "Oracle SQL에서 데이터베이스를 고가용성으로 구성하는 방법은?",
"options": [
"클러스터링",
"인덱싱",
"파티셔닝",
"압축"
],
"correctAnswer": 0,
"hint": "고가용성을 위해 여러 노드를 사용하는 방법입니다.",
"difficulty": "hard",
"category": "데이터베이스 관리"
},
{
"id": 34,
"question": "Oracle SQL에서 인덱스의 효율성을 측정하는 지표는?",
"options": [
"클러스터링 팩터",
"분산도",
"인덱스 스캔",
"풀 테이블 스캔"
],
"correctAnswer": 0,
"hint": "인덱스 효율성을 나타내는 지표입니다.",
"difficulty": "hard",
"category": "성능 최적화"
},
{
"id": 35,
"question": "Oracle SQL에서 파티션 테이블의 데이터를 병합하는 명령어는?",
"options": [
"MERGE PARTITION",
"UNION PARTITION",
"COMBINE PARTITION",
"JOIN PARTITION"
],
"correctAnswer": 0,
"hint": "파티션 데이터를 병합하는 명령어입니다.",
"difficulty": "hard",
"category": "데이터베이스 관리"
},
{
"id": 36,
"question": "Oracle SQL에서 옵티마이저 모드를 설정하는 방법은?",
"options": [
"ALTER SESSION",
"SET OPTIMIZER_MODE",
"CHANGE OPTIMIZER",
"CONFIGURE OPTIMIZER"
],
"correctAnswer": 0,
"hint": "세션 수준에서 옵티마이저 모드를 설정합니다.",
"difficulty": "hard",
"category": "성능 최적화"
},
{
"id": 37,
"question": "Oracle SQL에서 데이터베이스의 세그먼트를 관리하는 방법은?",
"options": [
"세그먼트 어드바이저",
"인덱스 어드바이저",
"파티션 어드바이저",
"클러스터 어드바이저"
],
"correctAnswer": 0,
"hint": "세그먼트를 관리하는 데 사용하는 도구입니다.",
"difficulty": "hard",
"category": "데이터베이스 관리"
},
{
"id": 38,
"question": "Oracle SQL에서 데이터베이스의 성능을 모니터링하는 뷰는?",
"options": [
"V$SQL",
"V$SESSION",
"V$SYSTEM",
"V$DATABASE"
],
"correctAnswer": 0,
"hint": "SQL 성능을 모니터링하는 뷰입니다.",
"difficulty": "hard",
"category": "성능 최적화"
},
{
"id": 39,
"question": "Oracle SQL에서 파티션 키를 변경하는 명령어는?",
"options": [
"ALTER PARTITION",
"MODIFY PARTITION",
"CHANGE PARTITION",
"UPDATE PARTITION"
],
"correctAnswer": 0,
"hint": "파티션 키를 변경합니다.",
"difficulty": "hard",
"category": "데이터베이스 관리"
},
{
"id": 40,
"question": "Oracle SQL에서 데이터베이스의 재해 복구 계획을 수립하는 방법은?",
"options": [
"데이터 가용성",
"데이터 복구",
"데이터 백업",
"데이터 보호"
],
"correctAnswer": 2,
"hint": "재해 복구 계획의 중요한 요소입니다.",
"difficulty": "hard",
"category": "데이터베이스 관리"
},
{
"id": 41,
"question": "Oracle SQL에서 읽기 전용 트랜잭션을 시작하는 명령어는?",
"options": [
"SET TRANSACTION READ ONLY",
"START TRANSACTION READ ONLY",
"BEGIN TRANSACTION READ ONLY",
"INIT TRANSACTION READ ONLY"
],
"correctAnswer": 0,
"hint": "읽기 전용 트랜잭션을 시작합니다.",
"difficulty": "hard",
"category": "트랜잭션 관리"
},
{
"id": 42,
"question": "Oracle SQL에서 병렬 처리의 효과를 극대화하기 위해 사용하는 힌트는?",
"options": [
"PARALLEL",
"OPTIMIZE",
"FAST",
"SPEED"
],
"correctAnswer": 0,
"hint": "병렬 처리를 제어합니다.",
"difficulty": "hard",
"category": "성능 최적화"
},
{
"id": 43,
"question": "Oracle SQL에서 데이터베이스의 복구 시간을 최소화하는 방법은?",
"options": [
"RMAN",
"데이터 압축",
"데이터 파티셔닝",
"데이터 암호화"
],
"correctAnswer": 0,
"hint": "복구 도구입니다.",
"difficulty": "hard",
"category": "데이터베이스 관리"
},
{
"id": 44,
"question": "Oracle SQL에서 사용자 세션의 정보를 확인하는 뷰는?",
"options": [
"V$SESSION",
"V$SQL",
"V$SYSTEM",
"V$DATABASE"
],
"correctAnswer": 0,
"hint": "세션 정보를 제공합니다.",
"difficulty": "hard",
"category": "데이터베이스 관리"
},
{
"id": 45,
"question": "Oracle SQL에서 데이터베이스의 크기를 줄이는 주요 방법은?",
"options": [
"데이터 압축",
"데이터 암호화",
"데이터 파티셔닝",
"데이터 클러스터링"
],
"correctAnswer": 0,
"hint": "데이터 크기를 줄입니다.",
"difficulty": "hard",
"category": "데이터베이스 관리"
},
{
"id": 46,
"question": "Oracle SQL에서 뷰를 삭제하는 명령어는?",
"options": [
"DROP VIEW",
"DELETE VIEW",
"REMOVE VIEW",
"CLEAR VIEW"
],
"correctAnswer": 0,
"hint": "뷰를 삭제합니다.",
"difficulty": "hard",
"category": "데이터베이스 객체"
},
{
"id": 47,
"question": "Oracle SQL에서 특정 데이터베이스 사용자의 권한을 조회하는 명령어는?",
"options": [
"SELECT * FROM USER_ROLE_PRIVS",
"SHOW GRANTS",
"DESCRIBE USER",
"SELECT * FROM USER_PRIVILEGES"
],
"correctAnswer": 0,
"hint": "사용자 권한을 조회합니다.",
"difficulty": "hard",
"category": "데이터베이스 보안"
},
{
"id": 48,
"question": "Oracle SQL에서 데이터베이스 테이블의 통계를 수집하는 명령어는?",
"options": [
"ANALYZE TABLE",
"GATHER STATS",
"COLLECT STATS",
"COMPUTE STATS"
],
"correctAnswer": 0,
"hint": "테이블의 통계를 수집합니다.",
"difficulty": "hard",
"category": "성능 최적화"
},
{
"id": 49,
"question": "Oracle SQL에서 두 테이블을 결합하는 데 사용되는 JOIN 유형은?",
"options": [
"INNER JOIN",
"OUTER JOIN",
"LEFT JOIN",
"RIGHT JOIN"
],
"correctAnswer": 0,
"hint": "공통된 열을 기반으로 결합합니다.",
"difficulty": "hard",
"category": "데이터 조회"
},
{
  "id": 50,
  "question": "Oracle의 병렬 실행에 대한 설명으로 옳지 않은 것은?",
  "options": [
  "병렬 실행은 항상 성능을 향상시킨다.",
  "병렬 힌트를 사용하여 병렬 처리를 제어할 수 있다.",
  "병렬 실행은 CPU와 I/O 리소스를 많이 사용한다.",
  "병렬 실행의 효과는 작업의 특성과 시스템 리소스에 따라 다르다."
  ],
  "correctAnswer": 0,
  "hint": "병렬 실행이 항상 최선의 선택은 아닙니다. 상황에 따라 다릅니다.",
  "difficulty": "hard",
  "category": "성능 최적화"
}
]